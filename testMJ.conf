include required(classpath("application"))

webservice {
  port = 8644
  #interface = 0.0.0.0
  #binding-timeout = 5s
  #instance.name = "reference"
}

system {
  graceful-server-shutdown = true

  # Cromwell will cap the number of running workflows at N
  #max-concurrent-workflows = 5000

  # Cromwell will launch up to N submitted workflows at a time, regardless of how many open workflow slots exist
  #max-workflow-launch-count = 50

  # Number of seconds between workflow launches
  #new-workflow-poll-rate = 20

  # Since the WorkflowLogCopyRouter is initialized in code, this is the number of workers
  #number-of-workflow-log-copy-workers = 10

  # Default number of cache read workers
  #number-of-cache-read-workers = 25
}

workflow-options {
  # Directory where to write per workflow logs
  #workflow-log-dir: "cromwell-workflow-logs"
}

backend {
  default: LSF
  providers: {
    LSF {
      actor-factory = "cromwell.backend.impl.sfs.config.ConfigBackendLifecycleActorFactory"

      config {
        concurrent-job-limit = 10

        # `temporary-directory` creates the temporary directory for commands.
        # The expression is run from the execution directory for the script. The expression must create the directory
        temporary-directory = "$(mkdir -p /tmp/commands && echo /tmp/commands)"

        runtime-attributes = """
        Int cpus = 2
        Float memory_gb = 8
        String? docker
        String? job_group = /crom/compute-cruchagac
        """

        submit = """
          bsub \
            -J ${job_name} \
            -cwd ${cwd} \
            -o ${out} \
            -e ${err} \
            /usr/bin/env bash ${script}
        """
        submit-docker = """
          bsub \
            -g ${job_group}
            -q general
            -G compute-cruchagac
            -R ${"select[" + 'mem>' + memory_gb + "G" + ' && ncpus>' + cpus + '] rusage[mem=' + memory_gb + 'G] span[hosts=1]'}
            -cwd ${docker_cwd} \
            -o ${out} \
            -e ${err} \
            -M ${memory_gb + "G"}\
            -a "docker(${docker})" \
            ${job_shell} ${docker_script}
        """
        kill = "bkill ${job_id}"
        check-alive = "bjobs ${job_id}"
        job-id-regex = "Job <(\\d+)>.*"
      }
    }
  }
}
